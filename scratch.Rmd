---
title: "EDA"
author: "Paul Villanueva"
date: "5/1/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(data.table)
library(doParallel)
library(dplyr)
library(ggplot2)
library(igraph)
library(reshape2)
library(scales)
library(tidyverse)
library(GENIE3)

theme_set(theme_light())
```

# Helper functions

Generates a bootstrap distribution after B iterations of permuting the observed proteomic data. Due to the size of the network we want to only look at a significant interations. Most of the time this is an arbitrary value, but we can permute the columns of the data and generate a distribution of the correlations in order to more precisely choose are cut off. 

boostrap_cor simulates the distrbution of the correlations.

```{r}
bootstrap_cor <- function(dat.observed, B = 1000) {
  
  library(data.table)

  # dat.observed = proteomics.expr
  
  n <- ncol(dat.observed)
  
  boots = data.table(c_score = numeric(), counts = numeric())
    
    
    
  for (i in 1:B){
  dat.perm <- data.table(dat.observed[, sample(n, n, replace = TRUE)])
  
  cor.perm <- data.table(c(round(cor(dat.perm), 3)))
  cor.perm[, counts := .N, by = .(V1)]
  cor.perm <- unique(cor.perm)
  
  boots <- rbindlist(list(boots, cor.perm))[, lapply(.SD, sum, na.rm = TRUE), 
                                            by = .(c_score)]

  }

  boots <- boots %>% arrange(-c_score) %>% data.table()

  return(boots)
}
```

boostrap_qualtiles takes the distribution of the simulated data and sets the cut offs at 2.5% and 97.5% of the distribution. 
```{r}
bootstrap_quantiles <- function(boots) {
  boots[, prop := counts/sum(counts)]
  
  quantiles <- boots[, list(
    upper = c_score[sum(cumsum(prop) <= 0.025)],
    lower = c_score[sum(cumsum(prop) <= 0.975)]
  )]
  
  return(quantiles)
}
```

Take the correlation matrix with the cut offs and thresholds the values. If the correlation is above the upper quantile then the correlation is set to 1. If the correlation is below the lower quantile then the correlation is set to -1. If the correlation falls between these two quantiles, then the value is set to 0. 

```{r}
threshold_cor_matrix <- function(cor.matrix, quantiles){
  
  cor.matrix[cor.matrix > proteomics.quantiles$upper] <- 1
  cor.matrix[cor.matrix < proteomics.quantiles$lower] <- -1
  cor.matrix[cor.matrix < proteomics.quantiles$upper & cor.matrix > proteomics.quantiles$lower] <- 0
  
  return(cor.matrix)

}
```


# Metabolomics data

Reads in the metabolic data as a dataframe. 

```{r}
metabolomics <- read.delim("./data/raw/Metabolomics2.txt")
```

# Proteomics

Reads in the proteomics data as a dataframe.

```{r}
proteomics <- read.delim("./data/raw/Proteomics2.txt")
```


## Calculating correlations.

Pulls proteomics and creates a seperate dataframe using just the UNIQID and the H and L expression data.

```{r}
proteomics.expr <- proteomics %>% 
  column_to_rownames(var = "UNIQID") %>% 
  select(7:12) %>% 
  t()
```

This will calculate the correlation of the expression dataframe. 

```{r}
proteomics.cor <- cor(proteomics.expr)
```

### Visualization

Heat map of the protein-protein correlation matrix.

```{r}
ggplot(melt(proteomics.cor), aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  coord_equal() +
  labs(x = "", y = "", title = "Protein-protein interactions",
       subtitle = "Measured by Pearson correlation") + 
  scale_fill_gradient2(low = "red", mid = "black", high = "steelblue") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 2),
        axis.text.y = element_text(size = 2))
```


Bootstrapping protein interactions to get qualtiles and thresholds. 

```{r}
proteomics.expr.boots <- bootstrap_cor(proteomics.expr, B = 20)
proteomics.quantiles <- bootstrap_quantiles(proteomics.expr.boots)

```

Visualizing the distribution of the bootstrapped protein-protein correlation. 

```{r}
ggplot(proteomics.expr.boots, aes(x = c_score, y = counts)) + 
  geom_col() + 
  scale_y_continuous(limits = c(0, max(proteomics.expr.boots$counts))) + 
  labs(x = "Pearson correlation", y = "Counts",
       title = "Simulated correlation values",
       subtitle = "2.5% thresholds indicated") +
  geom_vline(xintercept = c(proteomics.quantiles$lower, proteomics.quantiles$upper), color = "#BB0000", linetype = 'dashed')
```
 

Updated heatmap showing only the significant correlations

```{r}
t <- threshold_cor_matrix(proteomics.cor, quantiles)
ggplot(melt(t), aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  coord_equal() +
  labs(x = "", y = "", title = "Significant protein-protein interactions",
       subtitle = "Measured by Pearson correlation") + 
  scale_fill_gradient2(low = "red", mid = "black", high = "steelblue") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 2),
        axis.text.y = element_text(size = 2),
        axis.ticks = element_blank())
```


Set the diagonal to 0 so that they don't get graphed in the network (`diag = FALSE` argument isn't working in `graph_from_adjaceny_matrix` for some reason).

```{r}
diag(proteomics.cor) <- 0
proteomics.cor <- proteomics.cor %>% 
  melt() %>% 
  filter(value != 0)
```

This writes out the protein-protein interaction network for use with Cytoscape.

```{r}
write.csv(proteomics.cor, "./data/grn_mats/proteomics_network.csv", quote = FALSE,
          row.names = FALSE)
```

Creates a protein-protein interaction graph from the (modified) correlation matrix, changes the size to be proportional to the degree of the node, and creates a separate attribute for the betweenness of the node.

```{r}

proteomics.g <- graph_from_adjacency_matrix(proteomics.cor, diag = TRUE,
                                            # weighted = TRUE, mode = "undirected"
                                            )
proteomics.g <- delete_vertices(proteomics.g, 
                                V(proteomics.g)[degree(proteomics.g) == 0])
V(proteomics.g)$size = degree(proteomics.g)
V(proteomics.g)$btwn <- betweenness(proteomics.g)
```

Plotting the graph. Mess around with it as you like. 

```{r}
fine = 500 
pal = colorRampPalette(c('white','red'))

graphCol = pal(fine)[as.numeric(cut(V(proteomics.g)$btwn, breaks = fine))]


plot(proteomics.g,
     vertex.label = NA,
     vertex.size = 5,
     layout = layout_with_fr(proteomics.g),
     edge.arrow.size = 0.1,
     vertex.color = graphCol,
     # edge.color = ifelse(E(proteomics.g)$weight == 1, 'green', 'red'),
     )
```


#  Transcriptomics

Read in transcriptomics data.

```{r}
transcriptomics <- read.delim("./data/raw/Transcriptomics2.txt")
```

### Building GRN

I ran GENIE3 several times for different combinations of samples:

1. PHOTOTROPH1 - PHOTOTROPH3
2. H1 - H3
3. L1 - L3
4. H1 - H3, L1 - L3
5. PHOTOTROPH1 - PHOTOTROPH3, H1 - H3, L1 - L3

I saved the resulting matrices in (unzipped) data/grn_mats/transcriptomics. The name corresponds to the columns I considered. You can read them in with:

```{r}
H1_H2_H3.distmat <- readRDS("./data/grn_mats/transcriptomics/t_H1-H2-H3.rds")
```

And from there, you can make a network by doing:

```{r}
H1_H2_H3.network <- graph_from_adjacency_matrix(H1_H2_H3.distmat)
```

```{r}
plot(H1_H2_H3.network)
```








